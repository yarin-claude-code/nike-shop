---
phase: 02-backend-api-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/products/dto/query-products.dto.ts
  - apps/backend/src/products/dto/product-response.dto.ts
  - apps/backend/src/products/products.service.ts
  - apps/backend/src/products/products.controller.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/products returns paginated products with brand, category, images, and variants"
    - "GET /api/products?search=nike returns products matching name, description, or brand"
    - "GET /api/products?brands=nike&minPrice=50&maxPrice=200 filters correctly"
    - "GET /api/products?sizes=10&colors=Black filters by variant properties without duplicates"
    - "GET /api/products?page=2&limit=10 returns correct pagination metadata"
    - "GET /api/products/:slug returns single product with all relations"
  artifacts:
    - path: "apps/backend/src/products/dto/query-products.dto.ts"
      provides: "Validated query parameters for filtering, search, pagination"
      contains: "QueryProductsDto"
    - path: "apps/backend/src/products/dto/product-response.dto.ts"
      provides: "Paginated response interface"
      contains: "PaginatedResponse"
    - path: "apps/backend/src/products/products.service.ts"
      provides: "QueryBuilder-based filtering, search, pagination"
      contains: "findAllWithFilters"
    - path: "apps/backend/src/products/products.controller.ts"
      provides: "Enhanced endpoints with query params"
      contains: "QueryProductsDto"
  key_links:
    - from: "apps/backend/src/products/products.controller.ts"
      to: "apps/backend/src/products/products.service.ts"
      via: "findAllWithFilters(query)"
      pattern: "findAllWithFilters"
    - from: "apps/backend/src/products/products.service.ts"
      to: "TypeORM QueryBuilder"
      via: "createQueryBuilder with leftJoinAndSelect"
      pattern: "createQueryBuilder.*product"
---

<objective>
Build the products API with filtering, search, and pagination using TypeORM QueryBuilder.

Purpose: Replace simple Repository.find() with QueryBuilder to support dynamic filtering by brand/size/color/price, ILIKE search across product name/description/brand, and offset-based pagination — all without N+1 queries.

Output: Enhanced products endpoint accepting query parameters for filtering, search, and pagination, returning paginated responses with metadata.
</objective>

<execution_context>
@C:/Users/Yarin David/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Yarin David/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-api-core/02-RESEARCH.md

@apps/backend/src/products/entities/product.entity.ts
@apps/backend/src/products/entities/product-variant.entity.ts
@apps/backend/src/products/entities/product-image.entity.ts
@apps/backend/src/products/products.service.ts
@apps/backend/src/products/products.controller.ts
@apps/backend/src/products/products.module.ts
@apps/backend/src/brands/entities/brand.entity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create product DTOs for query validation and paginated response</name>
  <files>
    apps/backend/src/products/dto/query-products.dto.ts
    apps/backend/src/products/dto/product-response.dto.ts
  </files>
  <action>
Create `apps/backend/src/products/dto/query-products.dto.ts`:
- Class `QueryProductsDto` with class-validator decorators
- `search?: string` — @IsOptional, @IsString
- `brands?: string[]` — @IsOptional, @IsArray, @IsString({ each: true }), @Transform to normalize single value to array
- `sizes?: string[]` — same pattern as brands
- `colors?: string[]` — same pattern as brands
- `minPrice?: number` — @IsOptional, @IsNumber, @Type(() => Number), @Min(0)
- `maxPrice?: number` — same pattern as minPrice
- `page?: number` — @IsOptional, @IsNumber, @Type(() => Number), @Min(1), default 1
- `limit?: number` — @IsOptional, @IsNumber, @Type(() => Number), @Min(1), @Max(100), default 20

Create `apps/backend/src/products/dto/product-response.dto.ts`:
- Generic interface `PaginatedResponse<T>` with `data: T[]` and `meta: { total: number; page: number; lastPage: number; perPage: number }`
- Export both the interface and a type alias `PaginatedProductResponse = PaginatedResponse<Product>`

Use class-transformer @Transform for array normalization: `({ value }) => Array.isArray(value) ? value : [value]`
  </action>
  <verify>
Run `npx tsc --noEmit` from apps/backend — no type errors. Verify files exist with correct exports.
  </verify>
  <done>Both DTO files exist with proper validation decorators and type definitions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement QueryBuilder service and enhanced controller with filtering, search, and pagination</name>
  <files>
    apps/backend/src/products/products.service.ts
    apps/backend/src/products/products.controller.ts
  </files>
  <action>
**products.service.ts** — Replace `findAll()` with `findAllWithFilters(query: QueryProductsDto)`:
- Use `this.productRepository.createQueryBuilder('product')` instead of Repository.find()
- `.leftJoinAndSelect('product.brand', 'brand')` — joins brand
- `.leftJoinAndSelect('product.category', 'category')` — joins category
- `.leftJoinAndSelect('product.images', 'images')` — joins images
- `.leftJoinAndSelect('product.variants', 'variants')` — joins variants
- `.where('product.isActive = :isActive', { isActive: true })` — base filter

Apply filters conditionally (check array length > 0 before IN clause to avoid empty array SQL error):
- Search: `andWhere('(product.name ILIKE :search OR product.description ILIKE :search OR brand.name ILIKE :search)', { search: '%${query.search}%' })`
- Brands: `andWhere('brand.slug IN (:...brands)', { brands: query.brands })`
- Sizes: `andWhere('variants.size IN (:...sizes)', { sizes: query.sizes })`
- Colors: `andWhere('variants.color IN (:...colors)', { colors: query.colors })`
- minPrice: `andWhere('product.price >= :minPrice', { minPrice: query.minPrice })`
- maxPrice: `andWhere('product.price <= :maxPrice', { maxPrice: query.maxPrice })`

Handle duplicate products from variant joins: When filtering by sizes or colors, use a subquery approach — first select distinct product IDs matching variant criteria, then use those IDs in the main query. This avoids row multiplication. Pattern:
```typescript
if (query.sizes?.length || query.colors?.length) {
  const subQuery = this.productRepository
    .createQueryBuilder('pv_product')
    .select('pv_product.id')
    .innerJoin('pv_product.variants', 'pv')
  if (query.sizes?.length) subQuery.andWhere('pv.size IN (:...sizes)', { sizes: query.sizes });
  if (query.colors?.length) subQuery.andWhere('pv.color IN (:...colors)', { colors: query.colors });
  qb.andWhere('product.id IN (' + subQuery.getQuery() + ')');
  qb.setParameters(subQuery.getParameters());
}
```

Pagination: `.skip((query.page - 1) * query.limit).take(query.limit)`
Order: `.orderBy('product.createdAt', 'DESC')`
Return: `const [data, total] = await qb.getManyAndCount()` then build PaginatedResponse with meta (total, page, lastPage, perPage).

Keep existing `findFeatured()`, `findBySlug()`, `findByCategory()`, `findByBrand()` methods unchanged.

**products.controller.ts** — Update `findAll()`:
- Import `Query` from `@nestjs/common`
- Import `QueryProductsDto` from dto
- Change signature: `async findAll(@Query() query: QueryProductsDto): Promise<PaginatedResponse<Product>>`
- Call `this.productsService.findAllWithFilters(query)`
- Keep `findFeatured()` and `findBySlug()` routes unchanged
  </action>
  <verify>
1. `npx tsc --noEmit` from apps/backend — no type errors
2. `npm run build` from apps/backend — builds successfully
3. If database is available: `curl "http://localhost:3000/api/products"` returns `{ data: [...], meta: { total, page, lastPage, perPage } }`
4. `curl "http://localhost:3000/api/products?search=nike"` returns filtered results
5. `curl "http://localhost:3000/api/products?brands=nike&minPrice=100"` returns filtered results
6. `curl "http://localhost:3000/api/products?page=1&limit=5"` returns max 5 results with correct meta
  </verify>
  <done>Products endpoint accepts query params for search, brand/size/color/price filtering, and pagination. Returns PaginatedResponse with meta. No N+1 queries (uses QueryBuilder with explicit joins). No duplicate products when filtering by variant properties.</done>
</task>

</tasks>

<verification>
1. `npm run build` from project root — both apps build
2. `npx tsc --noEmit` from apps/backend — no type errors
3. GET /api/products returns paginated response with meta object
4. GET /api/products?search=test returns filtered results
5. GET /api/products?brands=nike&brands=adidas returns multi-brand filter
6. GET /api/products?page=2&limit=5 returns correct pagination
7. No N+1 queries visible in TypeORM logs
</verification>

<success_criteria>
Products API supports filtering (brand, size, color, price range), search (ILIKE on name/description/brand), and pagination with metadata — all using QueryBuilder with explicit joins to prevent N+1 queries.
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api-core/02-01-SUMMARY.md`
</output>
