---
phase: 02-backend-api-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/src/brands/brands.service.ts
  - apps/backend/src/brands/brands.controller.ts
  - apps/backend/src/brands/dto/brand-response.dto.ts
  - apps/backend/src/common/filters/http-exception.filter.ts
  - apps/backend/src/main.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/brands returns all brands with name, slug, logoUrl, description"
    - "GET /api/brands/:slug returns brand info with associated active products (images, category included)"
    - "404 returned for non-existent brand slug with structured error response"
    - "All API errors return consistent JSON format with statusCode, timestamp, path, message"
  artifacts:
    - path: "apps/backend/src/brands/brands.service.ts"
      provides: "Brand lookup with associated products via QueryBuilder"
      contains: "findBySlugWithProducts"
    - path: "apps/backend/src/brands/brands.controller.ts"
      provides: "Brand endpoints including slug-based product listing"
      contains: "findBySlug"
    - path: "apps/backend/src/brands/dto/brand-response.dto.ts"
      provides: "Brand response type definition"
      contains: "BrandWithProductsResponse"
    - path: "apps/backend/src/common/filters/http-exception.filter.ts"
      provides: "Global exception filter for consistent error responses"
      contains: "AllExceptionsFilter"
    - path: "apps/backend/src/main.ts"
      provides: "Global filter registration"
      contains: "AllExceptionsFilter"
  key_links:
    - from: "apps/backend/src/brands/brands.controller.ts"
      to: "apps/backend/src/brands/brands.service.ts"
      via: "findBySlugWithProducts(slug)"
      pattern: "findBySlugWithProducts"
    - from: "apps/backend/src/brands/brands.service.ts"
      to: "TypeORM QueryBuilder"
      via: "createQueryBuilder with leftJoinAndSelect for products"
      pattern: "createQueryBuilder.*brand"
    - from: "apps/backend/src/main.ts"
      to: "apps/backend/src/common/filters/http-exception.filter.ts"
      via: "app.useGlobalFilters"
      pattern: "useGlobalFilters.*AllExceptionsFilter"
---

<objective>
Build brand pages endpoint and global error handling infrastructure.

Purpose: Enable brand landing pages by returning brand info with associated products in a single optimized query. Add global exception filter for consistent API error responses across all endpoints.

Output: Brand detail endpoint with products, and global exception filter registered in main.ts.
</objective>

<execution_context>
@C:/Users/Yarin David/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Yarin David/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-api-core/02-RESEARCH.md

@apps/backend/src/brands/entities/brand.entity.ts
@apps/backend/src/brands/brands.service.ts
@apps/backend/src/brands/brands.controller.ts
@apps/backend/src/brands/brands.module.ts
@apps/backend/src/products/entities/product.entity.ts
@apps/backend/src/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance brands service and controller with slug-based product listing</name>
  <files>
    apps/backend/src/brands/brands.service.ts
    apps/backend/src/brands/brands.controller.ts
    apps/backend/src/brands/dto/brand-response.dto.ts
  </files>
  <action>
**brands/dto/brand-response.dto.ts** — Create response type:
- Interface `BrandWithProductsResponse` extending or wrapping Brand entity with `products: Product[]`
- Keep simple — no class-transformer serialization needed for brands (few fields, all safe to expose)

**brands.service.ts** — Add `findBySlugWithProducts(slug: string)`:
- Remove the `seedBrands()` method and `OnModuleInit` implementation — seeding is now handled by Phase 1 seeder infrastructure (typeorm-extension seeders), not by service init
- Remove `IsNull, Not` imports from typeorm (no longer needed after seedBrands removal)
- Keep existing `findAll()` method but simplify — just `return this.brandRepository.find({ order: { name: 'ASC' } })`
- Add new method using QueryBuilder:
```typescript
async findBySlugWithProducts(slug: string): Promise<Brand> {
  const brand = await this.brandRepository
    .createQueryBuilder('brand')
    .leftJoinAndSelect('brand.products', 'product', 'product.isActive = :isActive', { isActive: true })
    .leftJoinAndSelect('product.images', 'images')
    .leftJoinAndSelect('product.category', 'category')
    .leftJoinAndSelect('product.variants', 'variants')
    .where('brand.slug = :slug', { slug })
    .getOne();

  if (!brand) {
    throw new NotFoundException(`Brand with slug "${slug}" not found`);
  }

  return brand;
}
```
- Import `NotFoundException` from `@nestjs/common`

**brands.controller.ts** — Add slug endpoint:
- Add `@Get(':slug')` route with `@Param('slug') slug: string`
- Call `this.brandsService.findBySlugWithProducts(slug)`
- Return Brand with nested products
- Import `Param` from `@nestjs/common`
  </action>
  <verify>
1. `npx tsc --noEmit` from apps/backend — no type errors
2. `npm run build` from apps/backend — builds successfully
3. If database available: `curl http://localhost:3000/api/brands` returns brand list
4. `curl http://localhost:3000/api/brands/nike` returns brand with products array
5. `curl http://localhost:3000/api/brands/nonexistent` returns 404
  </verify>
  <done>Brand endpoint returns brand info with associated active products via single QueryBuilder query. Non-existent slugs return 404. Seed logic removed from service (handled by Phase 1 seeders).</done>
</task>

<task type="auto">
  <name>Task 2: Create global exception filter and register in main.ts</name>
  <files>
    apps/backend/src/common/filters/http-exception.filter.ts
    apps/backend/src/main.ts
  </files>
  <action>
**common/filters/http-exception.filter.ts** — Create global exception filter:
- Create directory `apps/backend/src/common/filters/`
- Implement `AllExceptionsFilter` implementing `ExceptionFilter`
- Use `@Catch()` decorator (catches all exceptions)
- Extract status from HttpException instances, default to 500
- Extract message from HttpException.getResponse() — handle both string and object responses
- Return consistent JSON: `{ statusCode, timestamp (ISO string), path (request URL), message }`
- For non-HttpException errors, log the error to console for debugging but return generic "Internal server error" to client

**main.ts** — Register the global filter:
- Import `AllExceptionsFilter` from `./common/filters/http-exception.filter`
- Add `app.useGlobalFilters(new AllExceptionsFilter())` after existing ValidationPipe setup
- Keep all existing configuration unchanged (CORS, prefix, ValidationPipe, port)
  </action>
  <verify>
1. `npx tsc --noEmit` from apps/backend — no type errors
2. `npm run build` from apps/backend — builds successfully
3. If running: `curl http://localhost:3000/api/nonexistent` returns `{ statusCode: 404, timestamp: "...", path: "/api/nonexistent", message: "Cannot GET /api/nonexistent" }`
4. `curl http://localhost:3000/api/brands/nonexistent` returns structured 404 with timestamp and path
  </verify>
  <done>All API errors return consistent JSON format with statusCode, timestamp, path, and message. Internal errors are logged server-side but return generic message to client.</done>
</task>

</tasks>

<verification>
1. `npm run build` from project root — both apps build
2. `npx tsc --noEmit` from apps/backend — no type errors
3. GET /api/brands returns brand list
4. GET /api/brands/nike returns brand with products array
5. GET /api/brands/nonexistent returns structured 404
6. All error responses have consistent { statusCode, timestamp, path, message } format
</verification>

<success_criteria>
Brand pages endpoint returns brand info with associated products via optimized QueryBuilder. Global exception filter ensures all API errors return consistent structured JSON responses.
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api-core/02-02-SUMMARY.md`
</output>
